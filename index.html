<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translator - Element Fullscreen</title>
    <style>
        :root {
            --primary-color: #007AFF; --primary-light: #EBF5FF; --background-color: #F0F2F5;
            --card-background-color: #FFFFFF; --text-color: #1C1C1E; --light-text-color: #FFFFFF;
            --border-color: #D1D1D6; --success-color: #34C759; --secondary-text-color: #6A737D;
            --action-blue: #0366D6; --danger-color: #d73a49; --warning-color: #FF9500;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --border-radius: 8px; --box-shadow: 0 3px 10px rgba(0, 0, 0, 0.07);
        }
        body { font-family: var(--font-family); margin: 0; background-color: var(--background-color); color: var(--text-color); display: flex; flex-direction: column; min-height: 100vh; line-height: 1.5; }
        .container { flex-grow: 1; max-width: 700px; margin: 20px auto; padding: 0 15px; width: 100%; box-sizing: border-box; position: relative; }
        .card { background-color: var(--card-background-color); padding: 25px; border-radius: var(--border-radius); box-shadow: var(--box-shadow); margin-top: 20px; }
        
        /* Styles for when the card is in fullscreen mode */
        .card:fullscreen {
            background-color: var(--background-color); /* Or your desired fullscreen background */
            padding: 20px; /* Adjust padding for fullscreen */
            overflow-y: auto; /* Allow scrolling if content exceeds screen height */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Optional: center content vertically */
        }
        .card:-webkit-full-screen { background-color: var(--background-color); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; justify-content: center;}
        .card:-moz-full-screen { background-color: var(--background-color); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; justify-content: center;}
        .card:-ms-fullscreen { background-color: var(--background-color); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; justify-content: center;}

        .language-selectors { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; gap: 15px; }
        .language-group { flex: 1; }
        .language-group label { display: block; font-weight: 500; margin-bottom: 6px; font-size: 0.85em; color: var(--secondary-text-color); }
        .language-group select { width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: var(--border-radius); font-size: 0.9em; background-color: #fff; color: var(--text-color); appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2220%22%20height%3D%2220%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M5%208l5%205%205-5z%22%20fill%3D%22%23555%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 10px center; background-size: 10px; box-sizing: border-box; }
        .input-area { position: relative; }
        .textarea-group { margin-bottom: 5px; }
         .textarea-group-header { 
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .textarea-group-header label { margin-bottom: 0; }
        textarea { width: 100%; min-height: 150px; padding: 10px; padding-right: 45px; border: 1px solid var(--border-color); border-radius: var(--border-radius); font-size: 0.95em; font-family: var(--font-family); box-sizing: border-box; resize: vertical; }
        textarea#outputText { padding-right: 10px; } 
        textarea:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); }
        #speechToTextBtn { position: absolute; bottom: 12px; right: 10px; background-color: transparent; border: none; padding: 8px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s; line-height: 0; }
        #speechToTextBtn:hover { opacity: 1; }
        #speechToTextBtn svg { width: 22px; height: 22px; fill: var(--secondary-text-color); vertical-align: middle; }
        #speechToTextBtn.listening svg { fill: var(--danger-color); }
        #textToSpeechBtn { background-color: transparent; border: none; padding: 5px; cursor: pointer; opacity: 0.7; line-height: 0; margin-left: 5px; display: inline-flex; align-items: center; justify-content: center;}
        #textToSpeechBtn:hover { opacity: 1; }
        #textToSpeechBtn svg { width: 20px; height: 20px; fill: var(--secondary-text-color); }
        #textToSpeechBtn.speaking svg { fill: var(--action-blue); }
        #speechStatus { font-size: 0.8em; color: var(--action-blue); margin-top: 5px; min-height: 1.2em; text-align: left; }
        .char-counter { font-size: 0.75em; color: var(--secondary-text-color); text-align: right; margin-bottom: 15px; padding-right: 5px; }
        .progress-bar-container { width: 100%; background-color: #e0e0e0; border-radius: var(--border-radius); margin: 10px 0; display: none; }
        .progress-bar { width: 0%; height: 10px; background-color: var(--success-color); border-radius: var(--border-radius); text-align: center; line-height: 10px; color: white; font-size: 0.7em; transition: width 0.3s ease-out; }
        .output-actions { display: flex; gap: 10px; margin-top: 10px; margin-bottom: 15px; }
        .action-button { flex-grow: 1; padding: 10px 15px; font-size: 0.9em; font-weight: 500; border-radius: var(--border-radius); cursor: pointer; border: none; color: var(--light-text-color); transition: background-color 0.2s; display: inline-flex; align-items: center; justify-content: center; }
        .action-button svg { margin-right: 8px; width: 16px; height: 16px; fill: currentColor; }
        #copyOutputBtn { background-color: var(--secondary-text-color); }
        #copyOutputBtn:hover { background-color: #555; }
        #shareOutputBtn { background-color: var(--action-blue); display: none; }
        #shareOutputBtn:hover { background-color: #0056b3; } 
        .translate-button { display: block; width: 100%; background-color: var(--success-color); color: var(--light-text-color); border: none; padding: 12px 15px; font-size: 1em; font-weight: 500; border-radius: var(--border-radius); cursor: pointer; transition: background-color 0.2s ease-in-out; text-align: center; margin-top: 10px; }
        .translate-button:hover { background-color: #28a745; }
        .translate-button:disabled { background-color: var(--secondary-text-color); cursor: not-allowed; opacity: 0.7; }
        footer { text-align: center; padding: 15px; font-size: 0.8em; color: var(--secondary-text-color); margin-top: 20px; }
        .fullscreen-toggle-container { text-align: right; margin-bottom: 10px; /* position: fixed; top: 10px; right: 10px; z-index: 1002; Optional: for fixed position */ }
        #fullscreenBtn { background: none; border: none; cursor: pointer; padding: 5px; opacity: 0.6; }
        #fullscreenBtn:hover { opacity: 1;}
        #fullscreenBtn svg { width: 20px; height: 20px; fill: var(--secondary-text-color); }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1003; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .modal-overlay.active { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
        .modal-content { background-color: var(--card-background-color); padding: 25px; border-radius: var(--border-radius); box-shadow: 0 5px 20px rgba(0,0,0,0.2); width: 90%; max-width: 450px; position: relative; transform: translateY(-20px); transition: transform 0.3s ease; text-align: center; }
        .modal-overlay.active .modal-content { transform: translateY(0); }
        .modal-content h2 { margin-top: 0; color: var(--primary-color); font-size: 1.3em; margin-bottom: 15px; }
        .modal-content p { font-size: 0.95em; line-height: 1.6; margin-bottom: 10px; }
        .modal-content ul { font-size: 0.85em; padding-left: 20px; margin-bottom: 20px; text-align: left; }
        .modal-content li { margin-bottom: 5px; }
        .modal-close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.8em; font-weight: bold; color: var(--secondary-text-color); cursor: pointer; border: none; background: none; }
        .modal-close-btn:hover { color: var(--text-color); }
        .modal-button.primary { background-color: var(--action-blue); color: white; display: block; width: 100%; padding: 10px 15px; border: none; border-radius: var(--border-radius); cursor: pointer; font-size: 0.95em; margin-top: 15px; transition: background-color 0.2s; }
        .modal-button.primary:hover { background-color: #0056b3; }
        @media (max-width: 480px) { .language-selectors { flex-direction: column; align-items: stretch; } .language-group { width: 100%; } .card { padding: 15px; } .output-actions { flex-direction: column;} }
    </style>
</head>
<body>
    <div class="container">
        <div class="fullscreen-toggle-container">
            <button id="fullscreenBtn" title="Toggle Fullscreen">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 2h2v3h-2v2h-3v-2h3v-3zm2-4v5h-2V7h-3V5h5z"/>
                </svg>
            </button>
        </div>
        
        <div class="card"> <!-- This is the element that will go fullscreen -->
            <p style="font-size: 0.8em; color: var(--secondary-text-color); text-align: center; margin-top: -10px; margin-bottom: 15px;">
            </p>
            <div class="language-selectors">
                <div class="language-group"><label for="sourceLanguage">Translate From (Speech Language):</label><select id="sourceLanguage"></select></div>
                <div class="language-group"><label for="targetLanguage">Translate To:</label><select id="targetLanguage"></select></div>
            </div>
            <div class="textarea-group">
                <label for="inputText">Enter Text or Use Microphone:</label>
                <div class="input-area">
                    <textarea id="inputText" placeholder="Type or speak text here..."></textarea>
                    <button id="speechToTextBtn" title="Speak to Input Text">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                            <path d="M12 15c1.657 0 3-1.343 3-3V5c0-1.657-1.343-3-3-3S9 3.343 9 5v7c0 1.657 1.343 3 3 3zm-1-9c0-.552.448-1 1-1s1 .448 1 1v7c0 .552-.448 1-1 1s-1-.448-1-1V6zm8.001 3.499c-.001 2.761-2.239 4.999-5.001 5v2.501h2c.552 0 .999.448.999 1s-.447 1-.999 1H8c-.552 0-.999-.448-.999-1s.447-1 .999-1h2V14.5c-2.761-.001-5-2.239-5.001-5H4c.001 3.313 2.687 6 6.001 6v2.5H8c-.552 0-.999.448-.999-1s.447 1 .999 1h8c.552 0 .999-.448.999-1s-.447-1-.999-1h-2V15.5c3.313 0 5.999-2.687 6.001-6h-1.999z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <p id="speechStatus"></p> 
            <div id="inputCharCounter" class="char-counter">0 / 25000</div>
            <div class="progress-bar-container" id="progressBarContainer"><div class="progress-bar" id="progressBar"></div></div>
            
            <div class="textarea-group">
                <div class="textarea-group-header">
                    <label for="outputText">Translated Text:</label>
                    <button id="textToSpeechBtn" title="Listen to Translated Text">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    </button>
                </div>
                <textarea id="outputText" placeholder="Translation will appear here..." readonly></textarea>
            </div>

             <div class="output-actions">
                <button id="copyOutputBtn" class="action-button">
                    <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1.5 4H8l-2 2v10l2 2h6.5l2-2V7l-2-2zM15 17H8.5V7.5H15V17z"></path></svg>
                    Copy Text
                </button>
                <button id="shareOutputBtn" class="action-button"> 
                    <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M10 3a2 2 0 100 4 2 2 0 000-4zM7 9a3 3 0 100-6 3 3 0 000 6zm8.707 2.293a1 1 0 00-1.414 0L13 12.586V9a1 1 0 10-2 0v3.586l-1.293-1.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 000-1.414zM13 7a3 3 0 100-6 3 3 0 000 6zm-1 9a1 1 0 10-2 0v.586L8.707 15.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L12 17.586V16z"></path></svg>
                    Share Text
                </button>
            </div>
            <button class="translate-button" id="translateBtn">Translate Text</button>
            <p id="actionStatus" style="font-size:0.8em; text-align:center; margin-top:8px; color: var(--success-color); min-height:1em;"></p>
        </div>
    </div>

    <footer><p>© 2023 Translator Demo.</p></footer>
    
    <div id="permissionModal" class="modal-overlay"> 
        <div class="modal-content">
            <span class="modal-close-btn" onclick="closePermissionModal()">×</span>
            <h2 id="permissionModalTitle">Permission Needed</h2> 
            <p id="permissionModalTextEl">This feature requires certain permissions. Please check your browser settings.</p> 
            <p><em>Instructions for common browsers are usually found by clicking the lock/info icon near the address bar.</em></p>
            <button onclick="closePermissionModal();" class="modal-button primary">Okay, I'll Check</button>
        </div>
    </div>

    <script>
        const languages = {};
        Object.assign(languages, { /* PASTE FULL languages OBJECT HERE */ 
            'auto': 'Auto Detect', 'af': 'Afrikaans', 'sq': 'Albanian', 'ar': 'Arabic', 'hy': 'Armenian', 'az': 'Azerbaijani', 'eu': 'Basque',
            'be': 'Belarusian', 'bn': 'Bengali', 'bs': 'Bosnian', 'bg': 'Bulgarian', 'ca': 'Catalan', 'ceb': 'Cebuano', 'ny': 'Chichewa',
            'zh-CN': 'Chinese (Simplified)', 'zh-TW': 'Chinese (Traditional)', 'co': 'Corsican', 'hr': 'Croatian', 'cs': 'Czech', 'da': 'Danish',
            'nl': 'Dutch', 'en': 'English', 'eo': 'Esperanto', 'et': 'Estonian', 'tl': 'Filipino', 'fi': 'Finnish', 'fr': 'French',
            'fy': 'Frisian', 'gl': 'Galician', 'ka': 'Georgian', 'de': 'German', 'el': 'Greek', 'gu': 'Gujarati', 'ht': 'Haitian Creole',
            'ha': 'Hausa', 'haw': 'Hawaiian', 'iw': 'Hebrew', 'he': 'Hebrew', 'hi': 'Hindi', 'hmn': 'Hmong', 'hu': 'Hungarian', 'is': 'Icelandic',
            'ig': 'Igbo', 'id': 'Indonesian', 'ga': 'Irish', 'it': 'Italian', 'ja': 'Japanese', 'jw': 'Javanese', 'kn': 'Kannada', 'kk': 'Kazakh',
            'km': 'Khmer', 'ko': 'Korean', 'ku': 'Kurdish (Kurmanji)', 'ky': 'Kyrgyz', 'lo': 'Lao', 'la': 'Latin', 'lv': 'Latvian', 'lt': 'Lithuanian',
            'lb': 'Luxembourgish', 'mk': 'Macedonian', 'mg': 'Malagasy', 'ms': 'Malay', 'ml': 'Malayalam', 'mt': 'Maltese', 'mi': 'Maori',
            'mr': 'Marathi', 'mn': 'Mongolian', 'my': 'Myanmar (Burmese)', 'ne': 'Nepali', 'no': 'Norwegian', 'or': 'Odia', 'ps': 'Pashto',
            'fa': 'Persian', 'pl': 'Polish', 'pt': 'Portuguese', 'pa': 'Punjabi', 'ro': 'Romanian', 'ru': 'Russian', 'sm': 'Samoan',
            'gd': 'Scots Gaelic', 'sr': 'Serbian', 'st': 'Sesotho', 'sn': 'Shona', 'sd': 'Sindhi', 'si': 'Sinhala', 'sk': 'Slovak',
            'sl': 'Slovenian', 'so': 'Somali', 'es': 'Spanish', 'su': 'Sundanese', 'sw': 'Swahili', 'sv': 'Swedish', 'tg': 'Tajik',
            'ta': 'Tamil', 'te': 'Telugu', 'th': 'Thai', 'tr': 'Turkish', 'uk': 'Ukrainian', 'ur': 'Urdu', 'ug': 'Uyghur', 'uz': 'Uzbek',
            'vi': 'Vietnamese', 'cy': 'Welsh', 'xh': 'Xhosa', 'yi': 'Yiddish', 'yo': 'Yoruba', 'zu': 'Zulu'
        });

        // DOM Elements
        const sourceLanguageSelect = document.getElementById('sourceLanguage');
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const inputTextEl = document.getElementById('inputText');
        const outputTextEl = document.getElementById('outputText');
        const translateBtn = document.getElementById('translateBtn');
        const inputCharCounterEl = document.getElementById('inputCharCounter');
        const progressBarContainerEl = document.getElementById('progressBarContainer');
        const progressBarEl = document.getElementById('progressBar');
        const copyOutputBtn = document.getElementById('copyOutputBtn');
        const shareOutputBtn = document.getElementById('shareOutputBtn'); 
        const actionStatusEl = document.getElementById('actionStatus'); 
        const speechToTextBtn = document.getElementById('speechToTextBtn'); 
        const speechStatusEl = document.getElementById('speechStatus'); 
        const textToSpeechBtn = document.getElementById('textToSpeechBtn'); 
        const permissionModalEl = document.getElementById('permissionModal');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const cardToFullscreen = document.querySelector('.card'); // Target the main card for fullscreen
        
        const MAX_INPUT_CHARS = 25000; 
        const API_CHUNK_LIMIT = 4500;   
        const API_REQUEST_DELAY = 500; 
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let isListening = false;

        const synth = window.speechSynthesis; 
        let currentUtterance = null; 

        if (SpeechRecognition) {
            try {
                recognition = new SpeechRecognition();
                recognition.continuous = false; 
                recognition.interimResults = false; 
                recognition.onstart = () => { isListening = true; speechToTextBtn.classList.add('listening'); speechStatusEl.textContent = "Listening... Speak now."; };
                recognition.onresult = (event) => { const transcript = event.results[0][0].transcript; inputTextEl.value = transcript; updateCharCounter(); speechStatusEl.textContent = "Speech recognized!"; };
                recognition.onerror = (event) => {
                    let message = `Speech error: ${event.error}.`;
                    if (event.error === 'no-speech') message = "No speech detected.";
                    else if (event.error === 'audio-capture') message = "Mic problem.";
                    else if (event.error === 'not-allowed') { message = "Mic permission denied."; showPermissionModal('Microphone Access Denied', 'This app needs microphone access.');}
                    else if (event.error === 'language-not-supported') message = `Speech lang not supported.`;
                    speechStatusEl.textContent = message;
                    isListening = false; speechToTextBtn.classList.remove('listening');
                };
                recognition.onend = () => { isListening = false; speechToTextBtn.classList.remove('listening'); if (speechStatusEl.textContent === "Listening... Speak now.") { speechStatusEl.textContent = "Finished. Click mic again.";}};
            } catch (e) { recognition = null; }
        }

        function showPermissionModal(title = "Permission Needed", text = "This feature requires permission.") { 
            if(permissionModalEl) {
                const modalTitle = permissionModalEl.querySelector('h2');
                const modalMainText = permissionModalEl.querySelector('#permissionModalTextEl'); 
                if(modalTitle) modalTitle.textContent = title;
                if(modalMainText) modalMainText.textContent = text; 
                else { const firstP = permissionModalEl.querySelector('p'); if (firstP) firstP.textContent = text; }
                permissionModalEl.classList.add('active'); 
            }
        }
        function closePermissionModal() { if(permissionModalEl) permissionModalEl.classList.remove('active'); }
        
        function populateLanguageSelectors() { /* ... (same) ... */ }
        async function translateSingleChunk(textChunk, sourceLang, targetLang) { /* ... (same) ... */ }
        async function translateLargeText(fullText, sourceLang, targetLang) { /* ... (same) ... */ }
        function updateCharCounter() { /* ... (same) ... */ }
        function displayActionStatus(message, success = true) { /* ... (same) ... */ }
        
        // --- Full implementations of stubbed functions ---
        populateLanguageSelectors = function() {
            sourceLanguageSelect.innerHTML = ''; targetLanguageSelect.innerHTML = '';
            for (const code in languages) {
                if (languages.hasOwnProperty(code)) { 
                    if (code === 'auto' || languages.hasOwnProperty(code)) {
                        const sourceOption = document.createElement('option'); sourceOption.value = code; sourceOption.textContent = languages[code]; sourceLanguageSelect.appendChild(sourceOption);
                    }
                    if (code !== 'auto') {
                        const targetOption = document.createElement('option'); targetOption.value = code; targetOption.textContent = languages[code]; targetLanguageSelect.appendChild(targetOption);
                    }
                }
            }
            sourceLanguageSelect.value = 'en'; targetLanguageSelect.value = 'es';
        };
        updateCharCounter = function() {
            const currentLength = inputTextEl.value.length;
            inputCharCounterEl.textContent = `${currentLength} / ${MAX_INPUT_CHARS}`;
        };
        translateSingleChunk = async function(textChunk, sourceLang, targetLang) {
            const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(textChunk)}`;
            try {
                const response = await fetch(url);
                if (!response.ok) { return `[Error chunk: ${response.status}]`; }
                const data = await response.json(); let translatedChunk = '';
                if (data && data[0] && Array.isArray(data[0])) { data[0].forEach(segment => { if (segment[0]) translatedChunk += segment[0]; });
                } else { translatedChunk = "[Chunk parse error]"; } return translatedChunk;
            } catch (error) { return "[Chunk network error]"; }
        };
        translateLargeText = async function(fullText, sourceLang, targetLang) {
            if(actionStatusEl) actionStatusEl.textContent = ''; 
            if (!fullText.trim()) { outputTextEl.value = ''; progressBarContainerEl.style.display = 'none'; return; }
            translateBtn.disabled = true; outputTextEl.value = 'Preparing...';
            progressBarContainerEl.style.display = 'block'; progressBarEl.style.width = '0%';
            const chunks = [];
            for (let i = 0; i < fullText.length; i += API_CHUNK_LIMIT) { chunks.push(fullText.substring(i, i + API_CHUNK_LIMIT)); }
            let combinedTranslation = ""; let errorsEncountered = false;
            for (let i = 0; i < chunks.length; i++) {
                outputTextEl.value = `Translating chunk ${i + 1}/${chunks.length}...`;
                const translatedSegment = await translateSingleChunk(chunks[i], sourceLang, targetLang);
                if (translatedSegment.startsWith("[Error") || translatedSegment.startsWith("[Chunk")) errorsEncountered = true;
                if (combinedTranslation.length > 0 && !/[\s.,!?;:)]$/.test(combinedTranslation.slice(-1)) && !/^[\s.,!?;:(]/.test(translatedSegment)) combinedTranslation += " "; 
                combinedTranslation += translatedSegment;
                const progress = Math.round(((i + 1) / chunks.length) * 100); progressBarEl.style.width = `${progress}%`;
                if (i < chunks.length - 1) await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY));
            }
            outputTextEl.value = combinedTranslation.trim();
            if (errorsEncountered) outputTextEl.value += "\n\n[Note: Some parts may have errors.]";
            translateBtn.disabled = false;
        };
        displayActionStatus = function(message, success = true) {
            if(actionStatusEl) {
                actionStatusEl.textContent = message;
                actionStatusEl.style.color = success ? 'var(--success-color)' : 'var(--danger-color)';
                setTimeout(() => { actionStatusEl.textContent = ''; }, 3000);
            }
        };
        // --- End of full implementations ---

        // Fullscreen API handling
        function toggleSpecificElementFullScreen(element) {
            if (!element) { console.error("Element for fullscreen not found!"); return; }
            if (!document.fullscreenElement) {
                if (element.requestFullscreen) element.requestFullscreen();
                else if (element.mozRequestFullScreen) element.mozRequestFullScreen();
                else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen();
                else if (element.msRequestFullscreen) element.msRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }

        function updateFullscreenButtonIcon() {
            if (!fullscreenBtn || !cardToFullscreen) return;
            const isElementFullscreen = document.fullscreenElement === cardToFullscreen;
            if (isElementFullscreen) {
                fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>`;
                fullscreenBtn.title = "Exit Fullscreen";
            } else {
                fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 2h2v3h-2v2h-3v-2h3v-3zm2-4v5h-2V7h-3V5h5z"/></svg>`;
                fullscreenBtn.title = "Enter Fullscreen";
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing app...");
            
            const localTextToSpeechBtn = document.getElementById('textToSpeechBtn');
            const localSpeechToTextBtn = document.getElementById('speechToTextBtn');
            const localShareOutputBtn = document.getElementById('shareOutputBtn'); 
            const localFullscreenBtn = document.getElementById('fullscreenBtn');
            const localCardToFullscreen = document.querySelector('.card');


            populateLanguageSelectors(); 
            updateCharCounter(); 

            inputTextEl.addEventListener('input', updateCharCounter);
            
            translateBtn.addEventListener('click', () => { /* ... (translate button logic) ... */ });
            copyOutputBtn.addEventListener('click', () => { /* ... (copy button logic) ... */ });

            if (localSpeechToTextBtn) { 
                if (SpeechRecognition && recognition) { 
                    localSpeechToTextBtn.addEventListener('click', () => { /* ... (STT logic) ... */ });
                } else { 
                    localSpeechToTextBtn.style.display = 'none';
                    if(speechStatusEl) speechStatusEl.textContent = "Speech input not supported.";
                }
            }

            if (localTextToSpeechBtn) { 
                if (synth) { 
                    localTextToSpeechBtn.style.display = 'inline-flex'; 
                    localTextToSpeechBtn.addEventListener('click', () => { /* ... (TTS logic) ... */ });
                } else { 
                    localTextToSpeechBtn.style.display = 'none'; 
                }
            }  

            if (localShareOutputBtn) {
                if (navigator.share) { 
                    localShareOutputBtn.style.display = 'inline-flex'; 
                    localShareOutputBtn.addEventListener('click', async () => {
                        const textToShare = outputTextEl.value;
                        const shareData = { title: 'Translated Text', text: textToShare };
                        if (textToShare) {
                            try { await navigator.share(shareData); displayActionStatus('Shared successfully!'); } 
                            catch (err) { displayActionStatus('Sharing cancelled or failed.', false); console.error('Share Error:', err); }
                        } else { displayActionStatus('Nothing to share.', false); }
                    });
                } else { 
                    localShareOutputBtn.style.display = 'none'; 
                    console.warn('Web Share API not supported, share button hidden.');
                }
            } else {
                console.log("Share button (shareOutputBtn) not found.");
            }

            if (localFullscreenBtn && localCardToFullscreen) {
                localFullscreenBtn.addEventListener('click', () => toggleSpecificElementFullScreen(localCardToFullscreen));
                document.addEventListener('fullscreenchange', updateFullscreenButtonIcon);
                document.addEventListener('webkitfullscreenchange', updateFullscreenButtonIcon);
                document.addEventListener('mozfullscreenchange', updateFullscreenButtonIcon);
                document.addEventListener('MSFullscreenChange', updateFullscreenButtonIcon);
                updateFullscreenButtonIcon(); 
            }
            
            // --- Re-pasting full event listener logic for clarity ---
            translateBtn.addEventListener('click', () => {
                const textToTranslate = inputTextEl.value.substring(0, MAX_INPUT_CHARS); 
                const sourceLangCode = sourceLanguageSelect.value; 
                const targetLangCode = targetLanguageSelect.value;
                if (sourceLangCode === targetLangCode && sourceLangCode !== 'auto') {
                    outputTextEl.value = textToTranslate; return;
                }
                translateLargeText(textToTranslate, sourceLangCode, targetLangCode);
            });
            copyOutputBtn.addEventListener('click', () => {
                const textToCopy = outputTextEl.value;
                if (textToCopy) {
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => { displayActionStatus('Translated text copied!'); })
                        .catch(err => { displayActionStatus('Failed to copy.', false); });
                } else { displayActionStatus('Nothing to copy.', false); }
            });
            if (localSpeechToTextBtn && SpeechRecognition && recognition) { 
                localSpeechToTextBtn.addEventListener('click', () => {
                    if (synth && synth.speaking) { 
                        synth.cancel();
                        if (localTextToSpeechBtn) localTextToSpeechBtn.classList.remove('speaking');
                        currentUtterance = null;
                    }
                    if (!isListening) {
                        try {
                            let speechLang = sourceLanguageSelect.value;
                            if (speechLang === 'auto' || speechLang.length > 5 || !/^[a-z]{2}(-([A-Z]{2}|[0-9]{3}))?$/.test(speechLang)) {
                                 speechLang = navigator.language || 'en-US'; 
                            }
                            recognition.lang = speechLang.replace('_', '-'); 
                            recognition.start(); 
                        } catch (e) {
                            if(speechStatusEl) speechStatusEl.textContent = "Error starting speech input.";
                            if (e.name === "NotAllowedError") {
                                showPermissionModal('Microphone Access Denied', 'This app needs microphone access.');
                            }
                        }
                    } else {
                        recognition.stop();
                    }
                });
            }
             if (localTextToSpeechBtn && synth) { 
                localTextToSpeechBtn.addEventListener('click', () => {
                    const textToSpeak = outputTextEl.value;
                    if (!textToSpeak.trim()) { displayActionStatus("Nothing to speak.", false); return; }
                    if (synth.speaking) { 
                        synth.cancel(); localTextToSpeechBtn.classList.remove('speaking');
                        if (currentUtterance && currentUtterance.text === textToSpeak) { currentUtterance = null; return; }
                    }
                    currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
                    let ttsLang = targetLanguageSelect.value;
                    if (ttsLang.length > 5 || !/^[a-z]{2}(-([A-Z]{2}|[0-9]{3}))?$/.test(ttsLang)) { ttsLang = navigator.language || 'en-US'; }
                    currentUtterance.lang = ttsLang.replace('_', '-');
                    currentUtterance.onstart = () => { localTextToSpeechBtn.classList.add('speaking'); };
                    currentUtterance.onend = () => { localTextToSpeechBtn.classList.remove('speaking'); currentUtterance = null; };
                    currentUtterance.onerror = (event) => { localTextToSpeechBtn.classList.remove('speaking'); currentUtterance = null; displayActionStatus(`Error speaking: ${event.error}`, false); };
                    synth.speak(currentUtterance);
                });
            } 
            // --- End of re-pasted listener logic ---

            console.log("App initialized.");
        });
    </script>
</body>
</html>